#需要复习的题目

==8.17==

**HJ7** **删除字符串中出现次数最少的字符**

https://www.nowcoder.com/practice/05182d328eb848dda7fdd5e029a56da9?tpId=387&tqId=36847&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D387 

```java

HashMap<Character, Integer> map = new HashMap<>();
 //声明了一个key为Character，value为Integer的对应关系

map.getOrDefault(c, 0)
 //获取集合中c对应的value，如果c不存在则为默认0
    
Collection<Integer> values = map.values();//返回一个值的集合映射
//创建一个map中value的映射集合
//Collections全部由静态方法组成，用来对 Collection 及其子接口/实现类做各种操作

Collections.min(values);//工具类Collections求集合中最小值

map.keySet()//返回map中所有键的集合
    
String.valueOf(c) //把c转换为字符串
    
map.get(c)//获取c在map中的value
```



**HJ19** **字符串排序**

https://www.nowcoder.com/practice/5190a1db6f4f4ddb92fd9c365c944584?tpId=387&tqId=36850&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D387

```java
List<Character> letters = new ArrayList<>(); //创建了一个用可变数组ArrayList实现的存储Char类型的list

Character.isLetter(ch) // 判断ch字符是否是字母
    
letters.sort(new Comparator<Character>() {
    //重写 compare(Character o1, Character o2) 方法，告诉排序器两个字符该怎样比大小
        public int compare(Character o1, Character o2) {
            //实现了一个“忽略大小写”的升序字母排序规则
            //compare(o1, o2) 方法约定：返回值 < 0 表示 o1 应排在 o2 之前（o1 “更小”）= 0 表示两者“相等” >0 表示 o1 应排在 o2 之后（o1 “更大”）
        	return Character.toLowerCase(o1) - Character.toLowerCase(o2);
       }
 });

Character.toLowerCase(c)//将c转换成小写字符
Character.toLowerCase(c)//判断c是否为小写字符   
```

**HJ20** **查找兄弟单词**

https://www.nowcoder.com/practice/03ba8aeeef73400ca7a37a5f3370fe68?tpId=387&tqId=36851&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D387

```java
Integer.parseInt(str) //把字符串str按十进制转换为int返回
    
Arrays.sort(s) //java.util.Arrays 类的一个静态方法调用 ，对数组s进行排序 。对字符数组（char[]）按字典序从小到大排序。对字符串数组（String[]）调用的是每个 String 的compareTo 方法逐字符比较字典序。
    
public String(char[] value) {//String 类里定义了多个重载的构造方法，这是其中一个
    this(value, 0, value.length);
}//把 char[] 变成 String 可以调用 String 的构造器

Collections.sort(list);//按照String.compareTo排序List

```



**HJ30** **取近似值**

https://www.nowcoder.com/practice/3ab09737afb645cc82c35d56a5ce802a?tpId=387&tqId=36831&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D387

第一次没有做出来，多复习

==8.18==

**围棋的气**

https://renjie.blog.csdn.net/article/details/135102594

```java
Arrays.toString(nums)//字符串nums转为数组
    
    for(int i = 0; i < white.length; i += 2){//遍历一维数组的坐标
            elements[white[i]][white[i + 1]] = 1;
        }

```

:star:**电脑病毒感染**

https://renjie.blog.csdn.net/article/details/135140349 //dijkstra

```java
PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
    //Comparator<T>，它定义了队列中元素的“优先级”比较规则,Comparator 唯一要实现的方法是int compare(T o1, T o2);如果 compare(o1, o2) < 0，就认为 o1 的优先级高（在小根堆里会排在前面）
    @Override
    public int compare(int[] a, int[] b) {
        return a[1] - b[1];
    }
});

PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
等价于
PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){
    @Override
    public int compare(int[] a, int[] b){
        return a[1] - b[1];
    }
});
```

